\pdfoutput=1

%% LyX 2.1.5 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{xargs}[2008/03/08]
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 0},backref=false,colorlinks=false]
 {hyperref}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% For printing a cirumflex inside a formula
\newcommand{\mathcircumflex}[0]{\mbox{\^{}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{bussproofs}
\usepackage{centernot}
\usepackage{datetime}
\usepackage{filecontents}
\usepackage{fullpage}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{tikz}
\usepackage{pgfplots}

\usetikzlibrary{automata}
\usetikzlibrary{backgrounds}
\usetikzlibrary{fit}
\usetikzlibrary{positioning}

\makeatother

\usepackage{listings}
\renewcommand{\lstlistingname}{Listing}

\begin{document}

\title{SyGuS Input Language Standard Version 2.0}


\author{Mukund Raghothaman \and Andrew Reynolds \and Abhishek Udupa}

\maketitle
\input{macros.tex}

\input{sygus-macros.tex}

\section{Introduction}
\label{sec:Introduction}

\ajr{Intro to sygus and example}

\subsection{Differences from Previous Versions}

In this section, we cover the differences
in this format with respect to the one described in the previous
SyGuS standard document~\cite{},
and the extensions described in~\cite{}.

\begin{enumerate}

\item The concrete syntax for the $\synthfunkwd$
was changed so that non-terminal symbols are declared upfront.
\rem{Mention Start symbol change if applicable.}

\item 
Terms that occur as the right hand side of production rules in
SyGuS grammars are now assumed to be binder-free,
in particular, this means that let-terms in this context are now disallowed.
Accordingly,
the keywords $\inputvarkwd$ and $\localvarkwd$,
which were used to specify input and local variables in grammars
respectively, have been removed.

\item The datatype keyword $\enumkwd$
and related syntactic features were removed.
The standard SMT LIB version 2.6 commands
for declaring datatypes are adopted.

\item The $\setoptskwd$ has been renamed $\setoptkwd$ to 
correlate to the existing SMT LIB version 2.6 command.\rem{TODO: Objection?}

\item 
The syntax for existing terms and sorts
that was not compliant with SMT LIB versions 2.0 and later have been removed.
This includes two notable exceptions from the previous format.
First,
the syntax for bit-vectors sorts ${\tt (BitVec\ n)}$
is now written  ${\tt (\_\ BitVec\ n)}$.
Second,
all let-bindings do \emph{not} annotate the type of the variable being bound.
Previously, a let-term could be written ${\tt (let\ ((x\ t\ T)) ...)}$
where ${\tt T}$ indicates the type of ${\tt t}$.
Now, it must be written in the SMT-LIB compliant
way ${\tt (let\ ((x\ t)) ...)}$.

%Furthermore, wherever applicable,
%the syntax for sorts and terms
%from other SMT theories assumes the syntax
%prescribed in theory definitions from SMT LIB~\cite{}.

\item The command $\primedvardeclkwd$, which is syntax
sugar for two $\vardeclkwd$ commands, has been removed
for the sake of simplicity.

%\item Change (fail)?

%\item Elaborations on the well-formedness of all commands.

\end{enumerate}

\section{Syntax}
\label{sec:syntax}

In this section, we describe the concrete syntax
of SyGuS version 2.0 inputs.
This syntax borrows many definitions
from the SMT-LIB version 2.6 format~\cite{}.
In the following description,
italicized text within angle-brackets represents EBNF non-terminals,
and text in typewriter font represents terminal symbols.

A SyGuS input $\sygus$ is thus a sequence of zero or more commands.
\[
\begin{array}{rcl}
\sygus & ::= & \kstar{\cmd}\\[2ex]
\end{array}
\]
The syntax for commands is given at the end of this section.
We first introduce the necessary preliminary definitions.

\subsection{Comments}

Comments in SyGuS specifications are indicated by a semicolon ${\tt ;}$.
After encountering a ${\tt ;}$, the rest of the line is ignored.

\subsection{Literals}
\label{ssec:literals}

A \emph{literal} $\literal$ is a special sequence of characters
used to denote values.
The SyGuS format includes syntax for several kinds of literals,
listed below.

\begin{alignat*}{1}
 & \begin{array}{rcl}
\literal & ::= & \begin{array}{ccccccccccc}
\intconst & | & \realconst & | & \boolconst & | \\
\hexconst & | & \binaryconst & | & \stringconst\end{array}\\
\intconst & ::= & \begin{array}{ccc}
\kplus{\left[{\tt 0}-{\tt 9}\right]} & | & {\tt -}\kplus{\left[{\tt 0}-{\tt 9}\right]}\end{array}\\
\realconst & ::= & \begin{array}{ccc}
\kplus{\left[{\tt 0}-{\tt 9}\right]}{\tt .}\kplus{\left[{\tt 0}-{\tt 9}\right]} & | & {\tt -}\kplus{\left[{\tt 0}-{\tt 9}\right]}{\tt .}\kplus{\left[{\tt 0}-{\tt 9}\right]}\end{array}\\
\boolconst & ::= & \begin{array}{ccc}
\truekwd & | & \falsekwd\end{array}\\
\hexconst & ::= & \begin{array}{c}
{\tt \#x}\kplus{\left(\begin{array}{ccccc}
\left[{\tt 0-9}\right] & | & \left[{\tt a}-{\tt f}\right] & | & \left[{\tt A}-{\tt F}\right]\end{array}\right)}\end{array}\\
\binaryconst & ::= & \begin{array}{c}
{\tt \#b}\kplus{\left[{\tt 0}-{\tt 1}\right]}\end{array}\\
\end{array}
\end{alignat*}

Integer constants are written as usual, in decimal, with an optional
minus at the beginning to denote a negative number. Real numbers are
written using their decimal expansion: at least one decimal digit
before and after a mandatory period, and an optional minus sign at
the beginning. $\truekwd$ and $\falsekwd$ are the predefined boolean
constants.
Hexidecimal and binary constants are written in their
traditional representations.

Additionally,
a string literal $\stringconst$
is any sequence of printable characters
delimited by double quotes ``''.
The characters within these delimiters
are interpreted as denoting characters of the string,
with one exception:
two consecutive double quotes within a string
denotes a single double quotes character.
In other words, ``${\tt a}$``''${\tt b}$'' denotes the string
whose characters are ${\tt a}$, '' and ${\tt b}$.
Notice that 
sequences such as ${\tt \backslash n}$ that are commonly
interpreted as escape sequences are not handled specially,
meaning the above sequence should be interpreted as a sequence of two characters.
%\rem{TODO: double quotes within strings escape, no other escape}
This treatment of string literals coincides with
string literals in the SMT LIB version 2.6 format.
For full details, see Section 3.1 of~\cite{}.

Literals are commonly
used for denoting 0-ary symbols of a theory.
For example, 
the theory of integer arithmetic 
uses integer constants to denote integer values.
The theory of bit-vectors uses both
hexidecimal and binary constants in the above syntax
to denote bit-vector vectors.
For more details on concrete theory definitions,
see Section~\ref{sec:smt-theories}.


\subsection{Symbols}

Symbols are denoted with the non-terminal $\symbol$. 
A symbol
is any non-empty sequence of upper- and lower-case alphabets, digits,
and certain special characters (listed below), with the restriction that it may not
begin with a digit and is not a reserved word (see Appendix~\ref{apx:reserved} 
for a full list of reserved words).
A special character is any of the following:
\[
{\tt \_}\mbox{ }{\tt +}\mbox{ }{\tt -}\mbox{ }{\tt *}\mbox{ }{\tt \&}\mbox{ }{\tt |}\mbox{ }{\tt !}\mbox{ }{\tt \sim}\mbox{ }{\tt <}\mbox{ }{\tt >}\mbox{ }{\tt =}\mbox{ }{\tt /}\mbox{ }{\tt \%}\mbox{ }{\tt ?}\mbox{ }{\tt .}\mbox{ }{\tt \$}\mbox{ }{\tt \mathcircumflex}
\]
Note this definition coincides with
symbols in Section 3.1 of the SMT LIB version 2.6 format,
apart from differences in their reserved words.

\subsection{Identifiers}

An identifier $\identifier$
is a syntactic extension of symbols 
that includes symbols that are indexed by integer constants or other symbols.
\[
\begin{array}{rcl}
\identifier & ::= & \begin{array}{ccc}
\symbol & | & \paren{{\tt \_}\mbox{ }\symbol\mbox{ }\kplus{\identifierindex}}
\end{array}\\
\identifierindex & ::= & \begin{array}{ccc}
\intconst & | & \symbol
\end{array}\\
\end{array}
\]
Note this definition coincides with
identifiers in Section 3.1 of the SMT LIB version 2.6 format.

\subsection{Sorts}

We work in a multi-sorted logic where terms 
are associated with sorts $\sortexpr$.
Sorts are constructed via the following syntax.
\begin{alignat*}{1}
 & \begin{array}{rcl}
\sortexpr & ::= & \identifier\mbox{ }|\mbox{ }\paren{\identifier\mbox{ }\kplus{\sortexpr}}\\
\end{array}
\end{alignat*}
The \emph{arity} of the sort is the number of (sort) arguments it takes.
A \emph{parametric} sort is one whose arity is greater than zero.
Theories associate identifiers with sorts and sort constructors
that have an intended semantics.
Sorts may be defined by theories (see examples in Section~\ref{sec:smt-theories})
or may be user-defined in certain logics
(see Section~\ref{ssec:defining-sorts}).

\subsection{Terms}

We use terms $\term$ to specify grammars and constraints,
which are constructed by the following syntax.
\begin{alignat*}{1}
 & \begin{array}{rcl}
\term & ::= & \qualidentifier\\
 & | & \literal\\
 & | & \paren{\qualidentifier\mbox{ }\kplus{\term}}\\
 & | & \paren{\existskwd\mbox{ }\paren{\kplus{\sortedvar}}\mbox{ }\term}\\
 & | & \paren{\forallkwd\mbox{ }\paren{\kplus{\sortedvar}}\mbox{ }\term}\\
 & | & \paren{\letkwd\mbox{ }\paren{\kplus{\varbinding}}\mbox{ }\term}\\[2ex]
 \bfterm & ::= & \qualidentifier\\
 & | & \literal\\
 & | & \paren{\qualidentifier\mbox{ }\kplus{\bfterm}}\\[2ex]
 \qualidentifier & ::= & \identifier\mbox{ }|\mbox{ }\paren{\askwd\mbox{ }\identifier\mbox{ }\sortexpr}\\
 \sortedvar & ::= & \paren{\symbol\mbox{ }\sortexpr}\\
 \varbinding & ::= & \paren{\symbol\mbox{ }\term}\\
\end{array}
\end{alignat*}
Above,
we distinguish a subclass of \emph{binder-free} terms $\bfterm$ in the syntax above,
which do not contain bound (local) variables.
Identifiers that comprise terms
may be \emph{qualified} with a type-cast, using the keyword $\askwd$.
Type casts are used for symbols whose type is ambiguous,
such as parametric datatype constructors, e.g. the nil constructor
for a parametric list.

Like sorts, the identifiers that comprise terms
can either be defined by the user or by the theory.
Examples of the latter are given in Section~\ref{sec:smt-theories}.

\subsection{Commands}

A command $\cmd$ is given by the following syntax.

\[
\begin{array}{rcl}
\cmd 
 & ::= & \paren{\constraintkwd\mbox{ }\term} \\
 & | & \paren{\checksynthkwd} \\
 & | & \paren{\vardeclkwd\mbox{ }\symbol\mbox{ }\sortexpr}\\ 
 & | & \paren{\constraintinvkwd\mbox{ }\symbol\mbox{ }\symbol\mbox{ }\symbol\mbox{ }\symbol} \\
 & | & \paren{\setextensionkwd\mbox{ }\symbol} \\
 & | & \paren{\synthfunkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\koption{\grammardef}}\\
 & | & \paren{\synthinvkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\koption{\grammardef}} \\
 & | & \smtcmd \\[2ex]
 %\paren{\constdeclkwd\mbox{ }\symbol\mbox{ }\sortexpr} \\
\smtcmd 
 & ::= & \paren{\fundeclkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortexpr}}\mbox{ }\sortexpr} \\
 & | & \paren{\dtdeclkwd\mbox{ }\symbol\mbox{ }\dtdec} \\
 & | & \paren{\dtsdeclkwd\mbox{ }\paren{\kstarn{\sortdecl}{n+1} }\mbox{ }\paren{\kstarn{\dtdec}{n+1}}} \\
 & | & \paren{\sortdeclkwd\mbox{ }\symbol\mbox{ }\intconst} \\
 & | & \paren{\fundefkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\term} \\  %\fundef
 %& | & \paren{\recfundefkwd\mbox{ }\fundef} \\
 %& | & \paren{\recfunsdefkwd\mbox{ }\paren{\kstarn{\fundec}{n+1}}\mbox{ }\paren{\kstarn{\term}{n+1}}} \\
 & | & \paren{\sortdefkwd\mbox{ }\symbol\mbox{ }\sortexpr} \\
 & | & \paren{\setlogickwd\mbox{ }\symbol} \\
 & | & \paren{\setoptkwd\mbox{ }\option} \\[2ex]
 \sortdecl & ::= & \paren{\symbol\mbox{ }\intconst}\\
 %\sortedvar & ::= & \paren{\symbol\mbox{ }\sortexpr}\\  %ajr: used above
 %\fundec & ::= & \paren{\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr}\\
 %\fundef & ::= & \symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\term\\
 \dtdec & ::= & \paren{\kplus{\dtconsdec}} \\
 \dtconsdec & ::= & \paren{\symbol\mbox{ }\kstar{\sortedvar}} \\
 \grammardef & ::= & \paren{\kstarn{\sortedvar}{n+1}}\mbox{ }\paren{\kstarn{\ntdef}{n+1}} \\
 \ntdef & ::= & \paren{\symbol\mbox{ }\paren{ \kplus{\gterm} } } \\[2ex]
 \gterm 
 & ::= &  \paren{\constantkwd\mbox{ }\sortexpr}\mbox{ }|\mbox{ }\paren{\varkwd\mbox{ }\sortexpr}\mbox{ }|\mbox{ }\bfterm\\
\end{array}
\]
For conveinence,
we distinguish two kinds of commands above.
The commands listed under $\cmd$ are specific to the SyGuS version 2.0 standard.
The remaining commands listed under $\smtcmd$
are borrowed from the SMT LIB version 2.6 standard.
Details on the semantics of these commands are given in Section~\ref{sec:semantics}.

%\paragraph{Reserved Words}
%All strings mentioned in Section~\ref{ssec:literals}


\section{Semantics of Commands}
\label{sec:semantics}

A SyGuS input file is a sequence of commands,
which at a high level
are used for defining a (single) synthesis conjecture
and invoking a solver for this conjecture.
This conjecture is of the form:
\begin{alignat*}{1}
 & \exists f_1,\ldots,f_n.\, \forall x_1,\ldots,x_m.\,(\varphi_1 \wedge \ldots \wedge \varphi_p )[f_1,\ldots,f_n,x_1,\ldots,x_m]
\end{alignat*}
In this section, we define how this conjecture is
is established via SyGuS commands.
%At a high level, 
%functions to synthesize $f_1, \ldots, f_n$ 
Given a sequence of commands, the current state consists of the following
information:
\begin{itemize}
\item A set
$f_1, \ldots, f_n$, which we refer to
as the current set of \emph{functions to synthesize},
\item A set 
$x_1, \ldots, x_m$ of variables, 
which we refer to the current set of \emph{universal variables}, 
\item A set of formulas
$\varphi_1, \ldots, \varphi_p$,
which we refer to as the current set of \emph{constraints},
\item A \emph{signature}
denoting the set of defined symbols in the current scope.
A signature is 
a mapping from symbols to expressions (either sorts or terms).
Each of these symbols may have a predefined semantics
either given by the theory,
or defined by the user (e.g. symbols that are defined as macros
fit the latter category).
\item A \emph{logic} denoting the
language of terms that may appear in constraints and grammars.
\end{itemize}

In the initial state of a SyGuS input,
the sets of functions-to-synthesize, 
universal variables, constraints, and the signature is empty,
and the logic is unspecified,
that is, 
no restrictions are placed on the set of terms that may appear 
in constraints and grammars.
In the following, we describe how each command $\cmd$ updates
the state of the sets above and the current signature.

\subsection{Setting the Logic}

\begin{itemize}
\item $\paren{\setlogickwd\mbox{ }S}$

This sets the background logic
to the one that $S$ refers to,
which can be a standard one defined in SMT-LIB~\cite{}
or may be solver-specific.
For examples of common SMT logics, 
see Section~\ref{sec:smt-theories}.
If $S$ is a standard SMT-LIB logic,
then this command adds the set of sort and function symbols
from that logic to the current signature.
In this case,
the logic must contain quantifiers or this command is not well-formed,
that is, logics with the prefix ``${\tt QF\_}$'' are not allowed.

In SyGuS, notice that the logic gives
restrictions on both the kinds of terms that
may appear in constraints, and may appear in grammars.
For the former,
we follow the same conventions as SMT-LIB
if $S$ is a standard SMT-LIB logic.
For the latter,
we give details on the default settings of the logic
with respect to restrictions on terms that may appear in grammars
in Section~\ref{ssec:dec-synth-fun}.

\item $\paren{\setextensionkwd\mbox{ }S}$

This enables the extension specified by $S$.
This may correspond enabling a feature of the language
or logic that is not supported by default.
\rem{Details, see}

\end{itemize}

\subsection{Declaring Universal Variables}

\begin{itemize}
\item $\paren{\vardeclkwd\mbox{ }S\mbox{ }\sigma}$

This command adds $S$ to the current set of universal variables
and adds the symbol $S$ of sort $\sigma$ to the current signature.

\rem{Name clashing}
%\item $\paren{\constdeclkwd\mbox{ }\symbol\mbox{ }\sortexpr}$

\item $\paren{\fundeclkwd\mbox{ }S\mbox{ }\paren{\sigma_1 \ldots \sigma_n}\mbox{ }\sigma}$

This command adds $S$ to the current set of universal variables.
The sort of $S$ is $\sigma$ if $n=0$ or
$\sigma_1 \times \ldots \times \sigma_n \rightarrow \sigma$ if $n>0$.
\rem{This is higher-order quantification}

\rem{Name clashing}

\rem{TODO: rename this ``declare-var-fun''? Parallel with declare-const -> declare-var.}

\end{itemize}

\subsection{Declaring Functions-to-Synthesize}
\label{ssec:dec-synth-fun}

\begin{itemize}
\item $\paren{\synthfunkwd\mbox{ }S\mbox{ }
\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\sigma\mbox{ }
\koption{G}}$

This command adds $S$ to the current set of functions to synthesize,
and adds the symbol $S$ of 
sort $\sigma_1 \times \ldots \times \sigma_n \rightarrow \sigma$
to the current signature.
We describe restrictions and well-formedness requirements for this command
in the following.

The syntax for the grammar $G$ (if provided)
consists of two parts: 
a \emph{predeclaration}
$\paren{\paren{y_1\mbox{ }\tau_1} \ldots \paren{y_n\mbox{ }\tau_n}}$,
followed by a \emph{grouped rule listing}
$\paren{\paren{y_1\mbox{ }\paren{g_{11} \ldots g_{1m_1} } } \ldots \paren{y_n\mbox{ }\paren{g_{n1} \ldots g_{nm_n} } }}$
where $y_1, \ldots, y_n$ are the \emph{non-terminal} symbols of the grammar.
For all $i,j$, recall that $g_{ij}$ is either a term, or a class of terms
denoted by $\paren{\constantkwd\mbox{ }\sigma_c}$ 
and $\paren{\varkwd\mbox{ }\sigma_v}$ denoting respectively
the (possibly infinte) set of constants whose sort is $\sigma_c$,
and the set of all variables from $x_1, \ldots, x_n$ whose sort is $\sigma_v$.
If $g_{ij}$ is an ordinary term, then its free variables may contain $y_1, \ldots, y_n$,
as well as $S$ itself, although the latter is disallowed in the default logic (see below).
Note that the same variable symbols
$y_1, \ldots, y_n$ appear both in the predeclaration and as heads
of each of the rules.
If this is not the case, then this command is not well-formed.
Furthermore,
this command is not well-formed if
$\tau_1$ is not $\sigma$.
\rem{TODO: should we make the first symbol of list the start symbol, instead of distinguished Start keyword?},
It is also not well-formed if
$G$ generates a term $t$ from $y_i$
that does not have type $\tau_i$ for some $i$.
Details on grammars and the terms
they generate is discussed in more detail in Section~\ref{ssec:sat-syntactic}.

If $G$ is not provided,
then this command is syntax
sugar for
$\paren{\synthfunkwd\mbox{ }S\mbox{ }
\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\sigma\mbox{ }
G_{\mathcal{L},\vec{x},\sigma}}$
where $G_{\mathcal{L},\vec{x},\sigma}$ is a grammar that
generates all well-sorted terms of sort $\sigma$ 
that belong to the language of the current background logic $\mathcal{L}$,
and whose free variables are in $\vec{x} = (x_1, \ldots, x_n)$.
%We call $G_{\mathcal{L},\sigma,\vec{x}}$ the \emph{default}
%grammar for $(T,\sigma,\vec{x})$.

\rem{Name clashing}

The grammar must also be one that is allowable by the logic.
This command does not meet the restrictions
of the background logic if $G$ generates some term $t$
such that $t$ does not belong to the background logic.
For instance, 
this restriction disallows grammars
in the logic of \emph{linear} integer arithmetic
for which it is possible to generate a term involving
the multiplication of two non-constant integer terms.
Notice, however, that grammar terms $g_{ij}$ may involve
the multiplication of two non-constant integer terms $t_1$ and $t_2$
e.g. in the case there one of $t_i$ is a non-terminal symbol $y$
for which $G$ generates only constant integer terms from $y$.
Commands where that not meet the restrictions
of the background logic should be rejected.

The default logic assumed by the SyGuS standard assumes
additional restrictions on the terms that are generated by grammars.
Note the following (recursive) definition.
A symbol $S$ \emph{depends on functions-to-synthesize}
if $S$ is a function-to-synthesize
or if it is a defined symbol whose definition $\lambda \vec{x}.\,t$
is such that $t$ contains a symbol that depends on
functions-to-synthesize.
%We say that $G$ has \emph{forward declarations}
%if 
%We say that $G$ is \emph{recursive} 
%if 
\rem{TODO}

\item $\paren{\synthinvkwd\mbox{ }S\mbox{ }\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\koption{G}}$

This is syntax sugar for
$\paren{\synthfunkwd\mbox{ }S\mbox{ }\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\boolkwd\mbox{ }\koption{G}}$.
\end{itemize}

\subsection{Defining Sorts}
\label{ssec:defining-sorts}

\begin{itemize}
\item $\paren{\dtdeclkwd\mbox{ }S\mbox{ }D}$

This is syntax sugar for
$\paren{\dtsdeclkwd\mbox{ }\paren{\paren{S\mbox{ }0} }\mbox{ }\paren{D}}$.

\item $\paren{\dtsdeclkwd\mbox{ }\paren{\paren{S_1\mbox{ }m_1}\ldots\paren{S_n\mbox{ }m_n} }\mbox{ }\paren{D_1 \ldots D_n}}$

This command adds the symbols $S_1, \ldots, S_n$ to the current signature
and associates it with a datatype sorts
whose definitions are given by $D_1, \ldots, D_n$.
The integer constant $m_i$ denotes the arity of datatype $D_i$.
%Datatypes whose arity is greater than $0$
%are called \emph{parametric datatypes}.
We provide examples of datatype definitions in Section~\ref{sec:examples}.
For full details on well-formed datatype declarations,
refer to Section 4.2.3 of the SMT LIB version 2.6~\cite{}.

\item $\paren{\sortdeclkwd\mbox{ }S\mbox{ }n}$

This command adds the symbol $S$ to the current signature
and associates it with an uninterpreted sort of arity $n$.

\rem{Name clashing}

\end{itemize}

\subsection{Defining Macros}

\begin{itemize}
\item $\paren{\fundefkwd\mbox{ }S\mbox{ }\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n}}\mbox{ }\sigma\mbox{ }t}$

This adds to the current signature
the symbol $S$ of sort $\sigma$
if $n=0$ or $\sigma_1 \times \ldots \sigma_n \rightarrow \sigma$ if $n>0$.
The variables $x_1, \ldots, x_n$ may occur freely in $t$.
It defines $S$ as a term whose semantics are given by the function
$\lambda x_1, \ldots, x_n.\, t$.
Notice that $t$ may not contain any free occurrences of $S$,
that is, the definition above is not recursive.
This command is not well-formed if $t$ is not a well-sorted
term of sort $\sigma$.

\rem{Name clashing}

\item $\paren{\sortdefkwd\mbox{ }S\mbox{ }\paren{u_1 \ldots u_n}\mbox{ }\sigma}$

This adds the symbol $S$ to the current signature.
It defines $S$ as the sort $\sigma$.
The sort variables $u_1, \ldots, u_n$
may occur free in $\sigma$,
while $S$ may not occur free in $\sigma$.
This command is not well-formed if $\sigma$
is not a well-formed sort.

\rem{Name clashing}

\end{itemize}

\subsection{Asserting Synthesis Constraints}

\begin{itemize}
\item $\paren{\constraintkwd\mbox{ }t}$

This adds $t$ to the set of constraints.
This command is well formed if $t$ is a well-sorted formula,
that is, a term of sort $\sbool$.

% constraint
\rem{Quantifiers implicit, but disallowed in contraints}
%We further require that $t$ is in the logic of 

\item $\paren{\constraintinvkwd\mbox{ }S\mbox{ }S_{pre}\mbox{ }S_{trans}\mbox{ }S_{post}}$

%This command is syntax-sugar for
%declaring a set of variables 
%and asserting a constraint corresponding to the invariant synthesis problem.
A constraint of this form is well-formed if:
\begin{enumerate}
\item
$S$ is function-to-synthesize
of sort $\sigma_1 \times \ldots \times \sigma_n \rightarrow \sbool$,
\item
$S_{pre}$ is a defined symbol 
whose definition is of the form $\lambda x_1, \ldots, x_n.\, \varphi_{pre}$,
\item
$S_{trans}$ is a defined symbol 
whose definition is of the form $\lambda x_1, \ldots, x_n, y_1, \ldots, y_n.\, \varphi_{trans}$, and
\item
$S_{post}$ is a defined symbol 
whose definition is of the form $\lambda x_1, \ldots, x_n.\, \varphi_{post}$.
\end{enumerate}
where $(x_1, \ldots, x_n)$ and $(y_1, \ldots, y_n)$
are tuples of variables of sort $(\sigma_1, \ldots, \sigma_n)$ and
$\varphi_{pre}$, $\varphi_{trans}$ and $\varphi_{post}$ are formulas.
Given that this command is well-formed, given the above definitions,
this command is syntax sugar for:
\[
\begin{array}{l}
\paren{\vardeclkwd\mbox{ }v_1\mbox{ }\sigma_1}\\
\paren{\vardeclkwd\mbox{ }v'_1\mbox{ }\sigma_1}\\
\ldots\\
\paren{\vardeclkwd\mbox{ }v_n\mbox{ }\sigma_n}\\
\paren{\vardeclkwd\mbox{ }v'_n\mbox{ }\sigma_n}\\
\paren{\constraintkwd\mbox{ }\paren{{\tt =>}\mbox{ }
\paren{S_{pre}\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n}\mbox{ }
\paren{S\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n}}}\\
\paren{\constraintkwd\mbox{ }\paren{{\tt =>}\mbox{ }
\paren{{\tt and}\mbox{ }\paren{S\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n}\mbox{ }
\paren{S_{trans}\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n\mbox{ }v'_1\mbox{ }\ldots\mbox{ }v'_n}}\mbox{ }
\paren{S\mbox{ }v'_1\mbox{ }\ldots\mbox{ }v'_n}}}\\
\paren{\constraintkwd\mbox{ }\paren{{\tt =>}\mbox{ }
\paren{S\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n}\mbox{ }
\paren{S_{post}\mbox{ }v_1\mbox{ }\ldots\mbox{ }v_n}}}\\
\end{array}
\]
where $v_1, v'_1, \ldots, v_n, v'_n$ are fresh symbols.

\end{itemize}

\subsection{Initiating Synthesis Solver}

\begin{itemize}
\item $\paren{\checksynthkwd}$

This asks the synthesis solver to find a solution for the synthesis conjecture
corresponding to the current set of functions-to-synthesize,
universal variables and constraints.
The expected output from the synthesis solver is covered in Section~\ref{sec:output}.
\end{itemize}

\subsection{Setting Solver Options}

\begin{itemize}
\item $\paren{\setoptkwd\mbox{ }O}$

This enables the solver-specific options specified by $O$.
We do not give concrete examples of such options in this document.\rem{Any needed?}
It is recommended that synthesis solvers
ignore unrecognized options, 
and choose reasonable defaults when the
options are left unspecified.
\end{itemize}

\section{Synthesis Solver Output}
\label{sec:output}

This section covers the expected output from a synthesis solver,
which currently is limited to responses to $\checksynthkwd$ 
only.

\begin{itemize}
\item
A well-formed response to $\checksynthkwd$ is one of the following:

\begin{enumerate}
\item
A list of $\fundefkwd$ commands of the form:
\[
\begin{array}{l}
\paren{\fundefkwd\mbox{ }f_{o1}\mbox{ }X_{o1}\mbox{ }\sigma_{o1}\mbox{ }t_{o1}}\\
\ldots\\
\paren{\fundefkwd\mbox{ }f_{on}\mbox{ }X_{on}\mbox{ }\sigma_{on}\mbox{ }t_{on}}
\end{array}
\]
where functions $\{ f_{o1}, \ldots, f_{on} \}$
are the functions-to-synthesize $\{ f_1,\ldots,f_n \}$ (in any order), 
$X_{o1}, \ldots, X_{on}$ are sorted variable lists,
$\sigma_{o1}, \ldots, \sigma_{on}$ are types,
and $t_{o1}, \ldots, t_{on}$ are terms.
To be a well-formed output, 
for each $j=1, \ldots, n$, it must be the case that
$t_{oj}$ is a term of $\sigma_{oj}$,
and $X_{oj}$ is identical to the sorted variable list
used when introducing the function-to-synthesize $f_{oj}$.

\item
The output ${\tt (fail)}$.

\end{enumerate}
\end{itemize}

%\section{

\section{Formal Semantics}
\label{sec:logical-semantics}

Here we give the formal semantics
for what consistites a correct solution for synthesis conjecture.

\subsection{Satisfying Syntactic Specifications}
\label{ssec:sat-syntactic}

In this section,
we formalize the notion of satisfying the \emph{syntactic specification}
of the synthesis conjecture.

As described in Section~\ref{ssec:dec-synth-fun},
a grammar $G$ is specified as
a \emph{grouped rule listing} of the form
\[
\paren{\paren{y_1\mbox{ }\paren{g_{11} \ldots g_{1m_1} } } \ldots 
\paren{y_n\mbox{ }\paren{g_{n1} \ldots g_{nm_n} } }}
\]
where $y_1, \ldots, y_n$ are variables
and $g_{11} \ldots g_{1m_1}, \ldots, g_{n1} \ldots g_{nm_n}$
are grammar terms.
We associate each grammar with a sorted variable list $X$,
namely the argument list of the function-to-synthesize.
We refer to $y_1$ as the \emph{start symbol} of $G$.

We interpret $G$ as a (possibly infinite) set of rules 
of the form $y \mapsto t$ where $t$ is an (ordinary) term
based on the following definition.
For each $y_i, g_{ik}$ in the grouped rule list,
if $g_{ik}$ is $\paren{\constantkwd\mbox{ }\sigma_c}$,
then $G$ contains the rule $y_i \mapsto c$ for all constants of sort $\sigma_c$.
If $g_{ik}$ is $\paren{\varkwd\mbox{ }\sigma_v}$,
then $G$ contains the rule $y_i \mapsto x$
for all variables $x \in X$ of sort $\sigma_v$.
Otherwise, if $g_{ik}$ is an ordinary term,
then $G$ contains the rule $y_i \mapsto g_{ik}$.

We say that $G$ \emph{generates} term $r$ from $s$
if it is possible to construct a sequence of terms
$s_1, \ldots, s_n$
with $s_1 = s$ and $s_n = r$
where for each $1 \leq i \leq n$, term $s_i$ is obtained from $s_{i-1}$ by
replacing an occurrence of some $y$ by $t$
where $y \mapsto t$ is a rule in $G$.

Let $f$ be a function to synthesize,
which recall is a grammar $G$
that are both associated with a common variable list $X$.
A term $\lambda X.\, t$
meets the syntactic specifications for $f$
if $G$ generates $t$ starting from $y_1$,
where $y_1$ is the start symbol of $G$.
%\rem{More}
%whose variable lists are $X_1, \ldots, X_n$
%and whose grammars are $G_1, \ldots, G_n$.


\subsection{Satisfying Semantic Specifications}
\label{ssec:sat-semantic}

In this section,
we formalize the notion of satisfying the \emph{semantic specification}
of the synthesis conjecture.

\rem{Reference smt semantics}

\section{SMT LIB Version 2.6 Theory References}
\label{sec:smt-theories}

In this section, for conveinence, we provide the concrete
grammar corresponding to the (full) signature
of a number of theories of interest.
Note this is not intended to be a complete list of all theories.

\subsection{Integer Arithmetic}



\subsection{Real Arithmetic}



\subsection{Fixed-Width Bit-Vectors}


\rem{extract/concat: multiple types}


\subsection{Strings}


\section{Standard SyGuS Logics}

\rem{Special logics: single invariant synthesis?}


\section{Examples}
\label{sec:examples}

\rem{Simple LIA example}

\rem{Datatypes}


\begin{appendix}

\section{Reserved Words}
\label{apx:reserved}

A \emph{reserved word} is any of the 
literals from Section~\ref{ssec:literals},
or any of the following keywords:

\section{Language Features of SMT LIB not Covered}

For the purpose of self-containment,
many of the essential language features of SMT LIB version 2.6
are redefined in this document.
However, others are omitted.
%We do not explicitly forbid the language features of SMT LIB .
We briefly mention other pertinent language features not mentioned in
this document.

Parametric datatypes

Recursive functions 

Match terms

Attribute annotations

\end{appendix}

\bibliographystyle{plain}
\bibliography{references}

\end{document}
