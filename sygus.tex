\pdfoutput=1

%% LyX 2.1.5 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{xargs}[2008/03/08]
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 0},backref=false,colorlinks=false]
 {hyperref}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% For printing a cirumflex inside a formula
\newcommand{\mathcircumflex}[0]{\mbox{\^{}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{bussproofs}
\usepackage{centernot}
\usepackage{datetime}
\usepackage{filecontents}
\usepackage{fullpage}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{tikz}
\usepackage{pgfplots}

\usetikzlibrary{automata}
\usetikzlibrary{backgrounds}
\usetikzlibrary{fit}
\usetikzlibrary{positioning}

\makeatother

\usepackage{listings}
\renewcommand{\lstlistingname}{Listing}

\begin{document}

\title{SyGuS Input Language Standard Version 2.0}


\author{Mukund Raghothaman \and Andrew Reynolds \and Abhishek Udupa}

\maketitle
\input{macros.tex}

\input{sygus-macros.tex}

\section{Introduction}
\label{sec:Introduction}

\ajr{Intro to sygus and example}

\subsection{Differences from Previous Versions}

In this section, we cover the differences
in this format with respect to the one described in the previous
SyGuS standard document~\cite{},
and the extensions described in~\cite{}.

\begin{enumerate}

\item The concrete syntax for the $\synthfunkwd$
was changed so that non-terminal symbols are declared upfront.

\item The datatype keyword $\enumkwd$
and related syntactic features were removed.
The standard SMT LIB version 2.6 commands
for declaring datatypes are adopted.

\item The command $\primedvardeclkwd$, which is syntax
sugar for two $\vardeclkwd$ commands, has been removed
for the sake of simplicity.

\item The $\setoptskwd$ has been renamed $\setoptkwd$.

\item The keywords $\inputvarkwd$ and $\localvarkwd$,
which were used to specify input and local variables in grammars
respectively, have been removed. These were removed
since grammars involving local variables cannot be expressed
in version 2.0.

\item 
The syntax for existing terms and sorts
that was not compliant with SMT LIB versions 2.0 and later have been removed.
This includes two notable exceptions from the previous format.
First,
the syntax for bit-vectors sorts ${\tt (BitVec\ n)}$
is now written  ${\tt (\_\ BitVec\ n)}$.
Second,
all let-bindings do \emph{not} annotate the type of the variable being bound.
%A let-binding
Furthermore, wherever applicable,
the syntax for sorts and terms
from other SMT theories assumes the syntax
prescribed in SMT LIB version 2.6.

%\rem{Syntax for terms assumes smt2: especially BitVec and 3 argument let}

%\item Change (fail)?

\item Elaborations on 

\end{enumerate}



\section{Syntax}
\label{sec:syntax}

\ajr{General relation to smt2}

In this section, we describe the concrete syntax
of SyGuS version 2.0 inputs.
In the following description,
italicized text within angle-brackets represents EBNF non-terminals,
and text in typewriter font represents terminal symbols.

\subsection{Comments}

Comments in SyGuS specifications are indicated by a semicolon ${\tt ;}$.
After encountering a ${\tt ;}$, the rest of the line is ignored.

\subsection{Literals}
\label{ssec:literals}

A \emph{literal} $\literal$ is a special sequence of characters.
The SyGuS format includes syntax for several kinds of literals,
listed below.

\begin{alignat*}{1}
 & \begin{array}{rcl}
\literal & ::= & \begin{array}{ccccccccccc}
\intconst & | & \realconst & | & \boolconst & | \\
\hexconst & | & \binaryconst & | & \stringconst\end{array}\\
\intconst & ::= & \begin{array}{ccc}
\kplus{\left[{\tt 0}-{\tt 9}\right]} & | & {\tt -}\kplus{\left[{\tt 0}-{\tt 9}\right]}\end{array}\\
\realconst & ::= & \begin{array}{ccc}
\kplus{\left[{\tt 0}-{\tt 9}\right]}{\tt .}\kplus{\left[{\tt 0}-{\tt 9}\right]} & | & {\tt -}\kplus{\left[{\tt 0}-{\tt 9}\right]}{\tt .}\kplus{\left[{\tt 0}-{\tt 9}\right]}\end{array}\\
\boolconst & ::= & \begin{array}{ccc}
\truekwd & | & \falsekwd\end{array}\\
\hexconst & ::= & \begin{array}{c}
{\tt \#x}\kplus{\left(\begin{array}{ccccc}
\left[{\tt 0-9}\right] & | & \left[{\tt a}-{\tt f}\right] & | & \left[{\tt A}-{\tt F}\right]\end{array}\right)}\end{array}\\
\binaryconst & ::= & \begin{array}{c}
{\tt \#b}\kplus{\left[{\tt 0}-{\tt 1}\right]}\end{array}\\
\end{array}
\end{alignat*}

Integer constants are written as usual, in decimal, with an optional
minus at the beginning to denote a negative number. Real numbers are
written using their decimal expansion: at least one decimal digit
before and after a mandatory period, and an optional minus sign at
the beginning. $\truekwd$ and $\falsekwd$ are the predefined boolean
constants.
Hexidecimal and binary constants are written in their
traditional representations.

Additionally,
a string literal $\stringconst$
is any sequence of printable characters
delimited by the double quotes character ${\tt ``}$.
\rem{TODO: double quotes escape}
This definition coincides with
string literals in Section 3.1 of the SMT LIB version 2.6 format.

Literals are commonly
used for denoting 0-ary symbols of a theory.
For example, 
the theory of integer arithmetic 
uses integer constants to denote integer values.
The theory of bit-vectors uses both
hexidecimal and binary constants in the above syntax
to denote bit-vector vectors.
For more details on concrete theory definitions,
see Section~\ref{sec:smt-theories}.


\subsection{Symbols}

Symbols are denoted with the non-terminal $\symbol$. 
A symbol
is any non-empty sequence of upper- and lower-case alphabets, digits,
and certain special characters (listed below), with the restriction that it may not
begin with a digit and is not a reserved word (see Appendix~\ref{apx:reserved} 
for a full list of reserved words).
A special character is any of the following:
\[
{\tt \_}\mbox{ }{\tt +}\mbox{ }{\tt -}\mbox{ }{\tt *}\mbox{ }{\tt \&}\mbox{ }{\tt |}\mbox{ }{\tt !}\mbox{ }{\tt \sim}\mbox{ }{\tt <}\mbox{ }{\tt >}\mbox{ }{\tt =}\mbox{ }{\tt /}\mbox{ }{\tt \%}\mbox{ }{\tt ?}\mbox{ }{\tt .}\mbox{ }{\tt \$}\mbox{ }{\tt \mathcircumflex}
\]
Note this definition coincides with
symbols in Section 3.1 of the SMT LIB version 2.6 format,
apart from differences in their reserved words.

\subsection{Identifier}

An identifier $\identifier$
is a syntactic extension of symbols 
that includes indexed symbols.
\[
\begin{array}{rcl}
\identifier & ::= & \begin{array}{ccc}
\symbol & | & \paren{{\tt \_}\mbox{ }\symbol\mbox{ }\kplus{\identifierindex}}
\end{array}\\
\identifierindex & ::= & \begin{array}{ccc}
\intconst & | & \symbol
\end{array}\\
\end{array}
\]
Note this definition coincides with
identifiers in Section 3.1 of the SMT LIB version 2.6 format.

\subsection{Sorts}

A sort $\sortexpr$ is


\subsection{Terms}

A term $\term$ is

\begin{alignat*}{1}
 & \begin{array}{rcl}
\term & ::= & \paren{\symbol\mbox{ }\kstar{\term}}\\
 & | & \literal\\
 & | & \symbol\\
 & | & \paren{\letkwd\mbox{ }\paren{\kplus{\paren{\symbol\mbox{ }\sortexpr}}}\mbox{ }\term}\\
\end{array}
\end{alignat*}

\subsection{Commands}

A command $\cmd$
is one of the following.

\[
\begin{array}{rcl}
\cmd 
 & ::= & \paren{\constraintkwd\mbox{ }\term} \\
 & | & \paren{\checksynthkwd} \\
 & | & \paren{\vardeclkwd\mbox{ }\symbol\mbox{ }\sortexpr}\\ 
 & | & \paren{\constraintinvkwd\mbox{ }\symbol\mbox{ }\symbol\mbox{ }\symbol\mbox{ }\symbol} \\
 & | & \paren{\setextensionkwd\mbox{ }\symbol} \\
 & | & \paren{\synthfunkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\koption{\grammardef}}\\
 & | & \paren{\synthinvkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\koption{\grammardef}} \\
 & | & \smtcmd \\[2ex]
 %\paren{\constdeclkwd\mbox{ }\symbol\mbox{ }\sortexpr} \\
\smtcmd 
 & ::= & \paren{\fundeclkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortexpr}}\mbox{ }\sortexpr} \\
 & | & \paren{\dtdeclkwd\mbox{ }\symbol\mbox{}\dtdec} \\
 & | & \paren{\dtsdeclkwd\mbox{ }\paren{\kstarn{\sortdecl}{n+1} }\mbox{ }\paren{\kstarn{\dtdec}{n+1}}} \\
 & | & \paren{\sortdeclkwd\mbox{ }\symbol\mbox{ }\intconst} \\
 & | & \paren{\fundefkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\term} \\  %\fundef
 %& | & \paren{\recfundefkwd\mbox{ }\fundef} \\
 %& | & \paren{\recfunsdefkwd\mbox{ }\paren{\kstarn{\fundec}{n+1}}\mbox{ }\paren{\kstarn{\term}{n+1}}} \\
 & | & \paren{\sortdefkwd\mbox{ }\symbol\mbox{ }\sortexpr} \\
 & | & \paren{\setlogickwd\mbox{ }\symbol} \\
 & | & \paren{\setoptkwd\mbox{ }\option} \\[2ex]
 \sortdecl & ::= & \paren{\symbol\mbox{ }\intconst}\\
 \sortedvar & ::= & \paren{\symbol\mbox{ }\sortexpr}\\
 %\fundec & ::= & \paren{\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr}\\
 %\fundef & ::= & \symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\term\\
 \dtdec & ::= & \paren{\kplus{\dtconsdec}} \\
 \dtconsdec & ::= & \paren{\symbol\mbox{ }\kstar{\sortedvar}} \\
 \grammardef & ::= & \paren{\kstarn{\sortedvar}{n+1}}\mbox{ }\paren{\kstarn{\ntdef}{n+1}} \\
 \ntdef & ::= & \paren{\symbol\mbox{ }\paren{ \kplus{\gterm} } } \\[2ex]
 \gterm 
 & ::= &  \paren{\constantkwd\mbox{ }\sortexpr}\\
 & | &\paren{\varkwd\mbox{ }\sortexpr}\\
 & | & \term\\
\end{array}
\]





A SyGuS input $\sygus$ is thus a sequence of zero or more commands.
\[
\begin{array}{rcl}
\sygus & ::= & \kstar{\cmd}\\[2ex]
\end{array}
\]

\paragraph{Reserved Words}
All strings mentioned in Section~\ref{ssec:literals}



\section{Semantics of Commands}
\label{sec:semantics}

A SyGuS input file is a sequence of commands whose syntax is given in
Figure~\ref{fig:commands}.
These commands are used for defining a (single) synthesis conjecture
and invoking a solver for this conjecture.
As mentioned this conjecture is of the form:
\begin{alignat*}{1}
 & \exists f_1,\ldots,f_n.\, \forall x_1,\ldots,x_m.\,\varphi[f_1,\ldots,f_n,x_1,\ldots,x_m]
\end{alignat*}
In this section, we define how $f_1, \ldots, f_n, x_1, \ldots, x_m, \varphi$
are established via SyGuS commands.
%At a high level, 
%functions to synthesize $f_1, \ldots, f_n$ 

\subsection{Setting the Logic}

\begin{itemize}
\item $\paren{\setlogickwd\mbox{ }\symbol}$


\item $\paren{\setextensionkwd\mbox{ }\symbol}$

\end{itemize}

\subsection{Declaring Universal Variables}

\begin{itemize}
\item $\paren{\vardeclkwd\mbox{ }\symbol\mbox{ }\sortexpr}$

%\item $\paren{\constdeclkwd\mbox{ }\symbol\mbox{ }\sortexpr}$

\item $\paren{\fundeclkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortexpr}}\mbox{ }\sortexpr}$

\end{itemize}

\subsection{Declaring Functions-to-Synthesize}

\begin{itemize}
\item $\paren{\synthfunkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\koption{\grammardef}}$

\item $\paren{\synthinvkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\koption{\grammardef}}$

\end{itemize}

\subsection{Defining Sorts}

\begin{itemize}
\item $\paren{\dtdeclkwd\mbox{ }\symbol\mbox{}\dtdec}$

\item $\paren{\dtsdeclkwd\mbox{ }\paren{\kstarn{\sortdecl}{n+1} }\mbox{ }\paren{\kstarn{\dtdec}{n+1}}}$

\item $\paren{\sortdeclkwd\mbox{ }\symbol\mbox{ }\intconst}$
\end{itemize}

\subsection{Defining Macros}

\begin{itemize}
\item $\paren{\fundefkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\term}$

\item $\paren{\sortdefkwd\mbox{ }\symbol\mbox{ }\sortexpr}$

%This command adds the sort specified by the symbol

\end{itemize}

\subsection{Asserting Synthesis Constraints}

\begin{itemize}
\item $\paren{\constraintkwd\mbox{ }\term}$

\item $\paren{\constraintinvkwd\mbox{ }\symbol\mbox{ }\symbol\mbox{ }\symbol\mbox{ }\symbol}$

This command is syntax-sugar for
declaring a set of variables and asserting a function.
A $\constraintinvkwd$ is well-formed if it is of the following form:
\rem{TODO}


\end{itemize}

\subsection{Initiating Synthesis Solver}

\begin{itemize}
\item $\paren{\checksynthkwd}$


\end{itemize}

\subsection{Setting Solver Options}

\begin{itemize}
\item $\paren{\setoptkwd\mbox{ }\option}$

\end{itemize}

\section{Synthesis Solver Output}

This section covers the expected output from a synthesis solver.

The synthesis solver is expected to respond with
output for the $\checksynthkwd$ command only.
A well-formed response to this command is one of the following:

\begin{enumerate}
\item
A list of $\fundefkwd$ commands of the form:
\[
\begin{array}{l}
{\tt (}\fundefkwd\mbox{ }f_{o1}\mbox{ }X_{o1}\mbox{ }\sigma_{o1}\mbox{ }t_{o1}{\tt )}\\
\ldots\\
{\tt (}\fundefkwd\mbox{ }f_{on}\mbox{ }X_{on}\mbox{ }\sigma_{on}\mbox{ }t_{on}{\tt )}
\end{array}
\]
where functions $\{ f_{o1}, \ldots, f_{on} \}$
are the functions-to-synthesize $\{ f_1,\ldots,f_n \}$ (in any order), 
$X_{o1}, \ldots, X_{on}$ are sorted variable lists,
$\sigma_{o1}, \ldots, \sigma_{on}$ are types,
and $t_{o1}, \ldots, t_{on}$ are terms.
To be a well-formed output, 
for each $j=1, \ldots, n$, it must be the case that
$t_{oj}$ is a term of $\sigma_{oj}$,
and the type of $\lambda X_{oj}.\, t_{oj}$ is the same as the type of $f_{oj}$.

\item
The output ${\tt (fail)}$.

\end{enumerate}


%\section{

\section{Logical Semantics and Restrictions}
\label{sec:logical-semantics}

\rem{Reference smt semantics}

\rem{Formalize fits grammar}

\rem{Summarize logic restrictions regarding what symbols appear where}

\section{SMT LIB Version 2.6 Theory References}
\label{sec:smt-theories}

In this section, for conveinence, we provide the concrete
grammar corresponding to the (full) signature
of a number of theories of interest.


\section{Examples}
\label{sec:examples}


\begin{appendix}

\section{Reserved Words}
\label{sec:reserved}

A \emph{reserved word} is any of the 
literals from Section~\ref{ssec:literals},
or any of the following keywords:

\end{appendix}

\bibliographystyle{plain}
\bibliography{references}

\end{document}
