\pdfoutput=1

%% LyX 2.1.5 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{xargs}[2008/03/08]
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 0},backref=false,colorlinks=false]
 {hyperref}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% For printing a cirumflex inside a formula
\newcommand{\mathcircumflex}[0]{\mbox{\^{}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{bussproofs}
\usepackage{centernot}
\usepackage{datetime}
\usepackage{filecontents}
\usepackage{fullpage}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{tikz}
\usepackage{pgfplots}

\usetikzlibrary{automata}
\usetikzlibrary{backgrounds}
\usetikzlibrary{fit}
\usetikzlibrary{positioning}

\makeatother

\usepackage{listings}
\renewcommand{\lstlistingname}{Listing}

\begin{document}

\title{SyGuS Input Language Standard Version 2.0}


\author{Mukund Raghothaman \and Andrew Reynolds \and Abhishek Udupa}

\maketitle
\input{macros.tex}

\input{sygus-macros.tex}

\section{Introduction}
\label{sec:Introduction}

\ajr{Intro to sygus and example}

\subsection{Differences from Previous Versions}

In this section, we cover the differences
in this format with respect to the one described in the previous
SyGuS standard document~\cite{},
and the extensions described in~\cite{}.

\begin{enumerate}

\item The concrete syntax for the $\synthfunkwd$
was changed so that non-terminal symbols are declared upfront.

\item The datatype keyword $\enumkwd$
and related syntactic features were removed.
The standard SMT LIB version 2.6 commands
for declaring datatypes are adopted.

\item The command $\primedvardeclkwd$, which is syntax
sugar for two $\vardeclkwd$ commands, has been removed
for the sake of simplicity.

\item The $\setoptskwd$ has been renamed $\setoptkwd$.

\item The keywords $\inputvarkwd$ and $\localvarkwd$,
which were used to specify input and local variables in grammars
respectively, have been removed. These were removed
since grammars involving local variables cannot be expressed
in version 2.0.

\item 
The syntax for existing terms and sorts
that was not compliant with SMT LIB versions 2.0 and later have been removed.
This includes two notable exceptions from the previous format.
First,
the syntax for bit-vectors sorts ${\tt (BitVec\ n)}$
is now written  ${\tt (\_\ BitVec\ n)}$.
Second,
all let-bindings do \emph{not} annotate the type of the variable being bound.
Previously, a let-term could be written ${\tt (let\ ((x\ t\ T)) ...)}$
where ${\tt T}$ indicates the type of ${\tt t}$.

%A let-binding
Furthermore, wherever applicable,
the syntax for sorts and terms
from other SMT theories assumes the syntax
prescribed in theory definitions from SMT LIB~\cite{}.


%\rem{Syntax for terms assumes smt2: especially BitVec and 3 argument let}

%\item Change (fail)?

\item Elaborations on the well-formedness of all commands.

\end{enumerate}

\section{Syntax}
\label{sec:syntax}

\ajr{General relation to smt2}

In this section, we describe the concrete syntax
of SyGuS version 2.0 inputs.
In the following description,
italicized text within angle-brackets represents EBNF non-terminals,
and text in typewriter font represents terminal symbols.

A SyGuS input $\sygus$ is thus a sequence of zero or more commands.
\[
\begin{array}{rcl}
\sygus & ::= & \kstar{\cmd}\\[2ex]
\end{array}
\]
The syntax for commands is given at the end of this section.
We first introduce the necessary preliminary definitions.

\subsection{Comments}

Comments in SyGuS specifications are indicated by a semicolon ${\tt ;}$.
After encountering a ${\tt ;}$, the rest of the line is ignored.

\subsection{Literals}
\label{ssec:literals}

A \emph{literal} $\literal$ is a special sequence of characters.
The SyGuS format includes syntax for several kinds of literals,
listed below.

\begin{alignat*}{1}
 & \begin{array}{rcl}
\literal & ::= & \begin{array}{ccccccccccc}
\intconst & | & \realconst & | & \boolconst & | \\
\hexconst & | & \binaryconst & | & \stringconst\end{array}\\
\intconst & ::= & \begin{array}{ccc}
\kplus{\left[{\tt 0}-{\tt 9}\right]} & | & {\tt -}\kplus{\left[{\tt 0}-{\tt 9}\right]}\end{array}\\
\realconst & ::= & \begin{array}{ccc}
\kplus{\left[{\tt 0}-{\tt 9}\right]}{\tt .}\kplus{\left[{\tt 0}-{\tt 9}\right]} & | & {\tt -}\kplus{\left[{\tt 0}-{\tt 9}\right]}{\tt .}\kplus{\left[{\tt 0}-{\tt 9}\right]}\end{array}\\
\boolconst & ::= & \begin{array}{ccc}
\truekwd & | & \falsekwd\end{array}\\
\hexconst & ::= & \begin{array}{c}
{\tt \#x}\kplus{\left(\begin{array}{ccccc}
\left[{\tt 0-9}\right] & | & \left[{\tt a}-{\tt f}\right] & | & \left[{\tt A}-{\tt F}\right]\end{array}\right)}\end{array}\\
\binaryconst & ::= & \begin{array}{c}
{\tt \#b}\kplus{\left[{\tt 0}-{\tt 1}\right]}\end{array}\\
\end{array}
\end{alignat*}

Integer constants are written as usual, in decimal, with an optional
minus at the beginning to denote a negative number. Real numbers are
written using their decimal expansion: at least one decimal digit
before and after a mandatory period, and an optional minus sign at
the beginning. $\truekwd$ and $\falsekwd$ are the predefined boolean
constants.
Hexidecimal and binary constants are written in their
traditional representations.

Additionally,
a string literal $\stringconst$
is any sequence of printable characters
delimited by the double quotes character ${\tt ``}$.
\rem{TODO: double quotes escape}
This definition coincides with
string literals in Section 3.1 of the SMT LIB version 2.6 format.

Literals are commonly
used for denoting 0-ary symbols of a theory.
For example, 
the theory of integer arithmetic 
uses integer constants to denote integer values.
The theory of bit-vectors uses both
hexidecimal and binary constants in the above syntax
to denote bit-vector vectors.
For more details on concrete theory definitions,
see Section~\ref{sec:smt-theories}.


\subsection{Symbols}

Symbols are denoted with the non-terminal $\symbol$. 
A symbol
is any non-empty sequence of upper- and lower-case alphabets, digits,
and certain special characters (listed below), with the restriction that it may not
begin with a digit and is not a reserved word (see Appendix~\ref{apx:reserved} 
for a full list of reserved words).
A special character is any of the following:
\[
{\tt \_}\mbox{ }{\tt +}\mbox{ }{\tt -}\mbox{ }{\tt *}\mbox{ }{\tt \&}\mbox{ }{\tt |}\mbox{ }{\tt !}\mbox{ }{\tt \sim}\mbox{ }{\tt <}\mbox{ }{\tt >}\mbox{ }{\tt =}\mbox{ }{\tt /}\mbox{ }{\tt \%}\mbox{ }{\tt ?}\mbox{ }{\tt .}\mbox{ }{\tt \$}\mbox{ }{\tt \mathcircumflex}
\]
Note this definition coincides with
symbols in Section 3.1 of the SMT LIB version 2.6 format,
apart from differences in their reserved words.

\subsection{Identifier}

An identifier $\identifier$
is a syntactic extension of symbols 
that includes indexed symbols.
\[
\begin{array}{rcl}
\identifier & ::= & \begin{array}{ccc}
\symbol & | & \paren{{\tt \_}\mbox{ }\symbol\mbox{ }\kplus{\identifierindex}}
\end{array}\\
\identifierindex & ::= & \begin{array}{ccc}
\intconst & | & \symbol
\end{array}\\
\end{array}
\]
Note this definition coincides with
identifiers in Section 3.1 of the SMT LIB version 2.6 format.

\subsection{Sorts}

A sort $\sortexpr$ denotes the

\begin{alignat*}{1}
 & \begin{array}{rcl}
\sortexpr & ::= & \identifier\mbox{ }|\mbox{ }\paren{\identifier\mbox{ }\kplus{\sortexpr}}\\
\end{array}
\end{alignat*}
Theories associate identifiers with sorts and sort constructors
that have an intended semantics.
Examples of such sorts that are defined by theories 
are given in Section~\ref{sec:smt-theories}.
Sorts may also be user-defined (see Section~\ref{ssec:defining-sorts}.

\subsection{Terms}

A term $\term$ is

\begin{alignat*}{1}
 & \begin{array}{rcl}
\term & ::= & \identifier\\
 & | & \literal\\
 & | & \paren{\identifier\mbox{ }\kplus{\term}}\\
 & | & \paren{\existskwd\mbox{ }\paren{\kplus{\sortedvar}}\mbox{ }\term}\\
 & | & \paren{\forallkwd\mbox{ }\paren{\kplus{\sortedvar}}\mbox{ }\term}\\
 & | & \paren{\letkwd\mbox{ }\paren{\kplus{\varbinding}}\mbox{ }\term}\\[2ex]
 \sortedvar & ::= & \paren{\symbol\mbox{ }\sortexpr}\\
 \varbinding & ::= & \paren{\symbol\mbox{ }\term}\\
\end{array}
\end{alignat*}
Like sorts, the identifiers that comprise terms
can either be defined by the user or 

theories associate identifiers with symbols
used to construct terms that have an intended semantics.
Examples are given in Section~\ref{sec:smt-theories}.


\subsection{Commands}

A command $\cmd$ is given by the following syntax.

\[
\begin{array}{rcl}
\cmd 
 & ::= & \paren{\constraintkwd\mbox{ }\term} \\
 & | & \paren{\checksynthkwd} \\
 & | & \paren{\vardeclkwd\mbox{ }\symbol\mbox{ }\sortexpr}\\ 
 & | & \paren{\constraintinvkwd\mbox{ }\symbol\mbox{ }\symbol\mbox{ }\symbol\mbox{ }\symbol} \\
 & | & \paren{\setextensionkwd\mbox{ }\symbol} \\
 & | & \paren{\synthfunkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\koption{\grammardef}}\\
 & | & \paren{\synthinvkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\koption{\grammardef}} \\
 & | & \smtcmd \\[2ex]
 %\paren{\constdeclkwd\mbox{ }\symbol\mbox{ }\sortexpr} \\
\smtcmd 
 & ::= & \paren{\fundeclkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortexpr}}\mbox{ }\sortexpr} \\
 & | & \paren{\dtdeclkwd\mbox{ }\symbol\mbox{ }\dtdec} \\
 & | & \paren{\dtsdeclkwd\mbox{ }\paren{\kstarn{\sortdecl}{n+1} }\mbox{ }\paren{\kstarn{\dtdec}{n+1}}} \\
 & | & \paren{\sortdeclkwd\mbox{ }\symbol\mbox{ }\intconst} \\
 & | & \paren{\fundefkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\term} \\  %\fundef
 %& | & \paren{\recfundefkwd\mbox{ }\fundef} \\
 %& | & \paren{\recfunsdefkwd\mbox{ }\paren{\kstarn{\fundec}{n+1}}\mbox{ }\paren{\kstarn{\term}{n+1}}} \\
 & | & \paren{\sortdefkwd\mbox{ }\symbol\mbox{ }\sortexpr} \\
 & | & \paren{\setlogickwd\mbox{ }\symbol} \\
 & | & \paren{\setoptkwd\mbox{ }\option} \\[2ex]
 \sortdecl & ::= & \paren{\symbol\mbox{ }\intconst}\\
 %\sortedvar & ::= & \paren{\symbol\mbox{ }\sortexpr}\\  %ajr: used above
 %\fundec & ::= & \paren{\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr}\\
 %\fundef & ::= & \symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\term\\
 \dtdec & ::= & \paren{\kplus{\dtconsdec}} \\
 \dtconsdec & ::= & \paren{\symbol\mbox{ }\kstar{\sortedvar}} \\
 \grammardef & ::= & \paren{\kstarn{\sortedvar}{n+1}}\mbox{ }\paren{\kstarn{\ntdef}{n+1}} \\
 \ntdef & ::= & \paren{\symbol\mbox{ }\paren{ \kplus{\gterm} } } \\[2ex]
 \gterm 
 & ::= &  \paren{\constantkwd\mbox{ }\sortexpr}\\
 & | &\paren{\varkwd\mbox{ }\sortexpr}\\
 & | & \term\\
\end{array}
\]
For conveinence,
we distinguish two kinds of commands above.
The commands listed under $\cmd$ are specific to the SyGuS version 2.0 standard.
The remaining commands listed under $\smtcmd$
are borrowed from the SMT LIB version 2.6 standard.
Details on the semantics of these commands are given in Section~\ref{sec:semantics}.

%\paragraph{Reserved Words}
%All strings mentioned in Section~\ref{ssec:literals}


\section{Semantics of Commands}
\label{sec:semantics}

A SyGuS input file is a sequence of commands,
which at a high level
are used for defining a (single) synthesis conjecture
and invoking a solver for this conjecture.
This conjecture is of the form:
\begin{alignat*}{1}
 & \exists f_1,\ldots,f_n.\, \forall x_1,\ldots,x_m.\,(\varphi_1 \wedge \ldots \wedge \varphi_p )[f_1,\ldots,f_n,x_1,\ldots,x_m]
\end{alignat*}
In this section, we define how this conjecture is
is established via SyGuS commands.
%At a high level, 
%functions to synthesize $f_1, \ldots, f_n$ 
In the following,
we refer to
$f_1, \ldots, f_n$ as the current set of \emph{functions to synthesize},
$x_1, \ldots, x_m$ as the current set of \emph{universal variables}, and 
$\varphi_1, \ldots, \varphi_p$ as the current set of \emph{constraints}.

We refer to the current \emph{signature}
as the set of defined symbols in the current scope.
In this context, 
a signature is 
a mapping from symbols to expressions (either sorts or terms).


In the following section, we describe how each command updates
the state of the sets above and the current signature.

\subsection{Setting the Logic}

\begin{itemize}
\item $\paren{\setlogickwd\mbox{ }S}$




\item $\paren{\setextensionkwd\mbox{ }S}$

This

\end{itemize}

\subsection{Declaring Universal Variables}

\begin{itemize}
\item $\paren{\vardeclkwd\mbox{ }S\mbox{ }\sigma}$

%\item $\paren{\constdeclkwd\mbox{ }\symbol\mbox{ }\sortexpr}$

\item $\paren{\fundeclkwd\mbox{ }S\mbox{ }\paren{\sigma_1 \ldots \sigma_n}\mbox{ }\sigma}$

\end{itemize}

\subsection{Declaring Functions-to-Synthesize}

\begin{itemize}
\item $\paren{\synthfunkwd\mbox{ }S\mbox{ }
\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\sigma\mbox{ }
\koption{G}}$

The syntax for the grammar $G$ (if provided)
consists of two parts: 
a \emph{predeclaration}
$\paren{\paren{y_1\mbox{ }\tau_1} \ldots \paren{y_n\mbox{ }\tau_n}}$,
followed by a \emph{rule list}
$\paren{\paren{y_1\mbox{ }\paren{g_{11} \ldots g_{1m_1} } } \ldots \paren{y_n\mbox{ }\paren{g_{n1} \ldots g_{1m_n} } }}$,
where notice we require that the same variable symbols
$y_1, \ldots, y_n$ appear both in the predeclaration and as heads
of each of the rules.
If this is not the case, then this command is not well-formed.
Recall that each $t_{ij}$ is a term or 
an instance of the special terms $\paren{\constantkwd\mbox{ }\sigma_c}$ 
and $\paren{\varkwd\mbox{ }\sigma_v}$ denoting respectively
the (possibly infinte) set of constants whose sort is $\sigma_c$,
and the set of all variables from $x_1, \ldots, x_n$ whose sort is $\sigma_v$.
If $t_{ij}$ is neither of these, then it is a term 
whose free variables may contain $y_1, \ldots, y_n$.
This command is not well-formed if
$\tau_1$ is not $\sigma$ \rem{First symbol of grammar instead of distinguished Start keyword?},
or if any

If $G$ is not provided,
then this command is syntax
sugar for
$\paren{\synthfunkwd\mbox{ }S\mbox{ }
\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\sigma\mbox{ }
G_{T,\vec{x},\sigma}}$
where $G_{T,\sigma,\vec{x}}$ is the \emph{default}
grammar for theory $T$, sort $\sigma$ and free variables $\vec{x} = ( x_1, \ldots, x_n )$.
\rem{Explain}

This command adds $S$ to the current set of functions to synthesize,
where the type of $S$ is $\sigma_1 \times \ldots \sigma_n \rightarrow \sigma$.


\item $\paren{\synthinvkwd\mbox{ }S\mbox{ }\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\koption{G}}$

This is syntax sugar for
$\paren{\synthfunkwd\mbox{ }S\mbox{ }\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\boolkwd\mbox{ }\koption{G}}$.
\end{itemize}

\subsection{Defining Sorts}
\label{ssec:defining-sorts}

\begin{itemize}
\item $\paren{\dtdeclkwd\mbox{ }S\mbox{ }D}$

\item $\paren{\dtsdeclkwd\mbox{ }\paren{\kstarn{\sortdecl}{n+1} }\mbox{ }\paren{\kstarn{D}{n+1}}}$

\item $\paren{\sortdeclkwd\mbox{ }S\mbox{ }n}$

This command adds the symbol $S$ to the current signature
and associates it with an uninterpreted sort of arity $n$.

\end{itemize}

\subsection{Defining Macros}

\begin{itemize}
\item $\paren{\fundefkwd\mbox{ }S\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sigma\mbox{ }t}$

\item $\paren{\sortdefkwd\mbox{ }S\mbox{ }\sigma}$

This adds the symbol $S$ to the current signature
and associates it with the sort defined by $\sigma$.

\end{itemize}

\subsection{Asserting Synthesis Constraints}

\begin{itemize}
\item $\paren{\constraintkwd\mbox{ }t}$

This adds $t$ to the set of constraints.
This command is well formed if $t$ is a formula,
that is, a term of Boolean sort.

\item $\paren{\constraintinvkwd\mbox{ }S\mbox{ }S_{pre}\mbox{ }S_{trans}\mbox{ }S_{post}}$

This command is syntax-sugar for
declaring a set of variables 
and asserting a constraint corresponding to the invariant synthesis
problem.
A constraint of this form is well-formed if
$S$ is function-to-synthesize
of sort $\sigma_1 \times \ldots \sigma_n \rightarrow \sigma$.
\rem{TODO}


\end{itemize}

\subsection{Initiating Synthesis Solver}

\begin{itemize}
\item $\paren{\checksynthkwd}$


\end{itemize}

\subsection{Setting Solver Options}

\begin{itemize}
\item $\paren{\setoptkwd\mbox{ }O}$

\end{itemize}

\section{Synthesis Solver Output}

This section covers the expected output from a synthesis solver.

The synthesis solver is expected to respond with
output for the $\checksynthkwd$ command only.
A well-formed response to this command is one of the following:

\begin{enumerate}
\item
A list of $\fundefkwd$ commands of the form:
\[
\begin{array}{l}
{\tt (}\fundefkwd\mbox{ }f_{o1}\mbox{ }X_{o1}\mbox{ }\sigma_{o1}\mbox{ }t_{o1}{\tt )}\\
\ldots\\
{\tt (}\fundefkwd\mbox{ }f_{on}\mbox{ }X_{on}\mbox{ }\sigma_{on}\mbox{ }t_{on}{\tt )}
\end{array}
\]
where functions $\{ f_{o1}, \ldots, f_{on} \}$
are the functions-to-synthesize $\{ f_1,\ldots,f_n \}$ (in any order), 
$X_{o1}, \ldots, X_{on}$ are sorted variable lists,
$\sigma_{o1}, \ldots, \sigma_{on}$ are types,
and $t_{o1}, \ldots, t_{on}$ are terms.
To be a well-formed output, 
for each $j=1, \ldots, n$, it must be the case that
$t_{oj}$ is a term of $\sigma_{oj}$,
and $X_{oj}$ is identical to the variable list associated with $f_{oj}$.

\item
The output ${\tt (fail)}$.

\end{enumerate}


%\section{

\section{Logical Semantics and Restrictions}
\label{sec:logical-semantics}

\rem{Reference smt semantics}

\rem{Formalize fits grammar}

\rem{Logic e.g. Non-linear vs linear: generated terms}

\rem{Summarize logic restrictions regarding what symbols appear where}

\section{SMT LIB Version 2.6 Theory References}
\label{sec:smt-theories}

In this section, for conveinence, we provide the concrete
grammar corresponding to the (full) signature
of a number of theories of interest.

\subsection{Integer Arithmetic}



\subsection{Real Arithmetic}



\subsection{Fixed-Width Bit-Vectors}



\subsection{Strings}


\section{Examples}
\label{sec:examples}


\begin{appendix}

\section{Reserved Words}
\label{sec:reserved}

A \emph{reserved word} is any of the 
literals from Section~\ref{ssec:literals},
or any of the following keywords:

\section{Language Features of SMT LIB not Covered}

For the purpose of self-containment,
many of the essential language features of SMT LIB version 2.6
are redefined in this document.
However, others are omitted.
%We do not explicitly forbid the language features of SMT LIB .
We briefly mention other pertinent language features not mentioned in
this document.

Parametric datatypes

Recursive functions 

Match terms

\end{appendix}

\bibliographystyle{plain}
\bibliography{references}

\end{document}
