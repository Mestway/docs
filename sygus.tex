\pdfoutput=1

%% LyX 2.1.5 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{xargs}[2008/03/08]
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 0},backref=false,colorlinks=false]
 {hyperref}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% For printing a cirumflex inside a formula
\newcommand{\mathcircumflex}[0]{\mbox{\^{}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{bussproofs}
\usepackage{centernot}
\usepackage{datetime}
\usepackage{filecontents}
\usepackage{fullpage}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{tikz}
\usepackage{pgfplots}

\usetikzlibrary{automata}
\usetikzlibrary{backgrounds}
\usetikzlibrary{fit}
\usetikzlibrary{positioning}

\makeatother

\usepackage{listings}
\renewcommand{\lstlistingname}{Listing}

\begin{document}

\title{SyGuS Input Language Standard Version 2.0}


\author{Mukund Raghothaman \and Andrew Reynolds \and Abhishek Udupa}

\maketitle
\input{macros.tex}

\input{sygus-macros.tex}

\section{Introduction}
\label{sec:Introduction}

\ajr{Intro to sygus and example}

\subsection{Differences from Previous Versions}

In this section, we cover the differences
in this format with respect to the one described in the previous
SyGuS standard document~\cite{},
and the extensions described in~\cite{}.

\begin{enumerate}

\item The concrete syntax for the $\synthfunkwd$
was changed so that non-terminal symbols are declared upfront.
\rem{Start symbol?}

\item 
Terms that occur as the right hand side of production rules in
SyGuS grammars are now assumed to be binder-free,
in particular, this means that let-terms in this context are now disallowed.
Accordingly,
the keywords $\inputvarkwd$ and $\localvarkwd$,
which were used to specify input and local variables in grammars
respectively, have been removed.

\item The datatype keyword $\enumkwd$
and related syntactic features were removed.
The standard SMT LIB version 2.6 commands
for declaring datatypes are adopted.

\item The $\setoptskwd$ has been renamed $\setoptkwd$ to 
correlate to the existing SMT LIB version 2.6 command.\rem{Objection?}

\item 
The syntax for existing terms and sorts
that was not compliant with SMT LIB versions 2.0 and later have been removed.
This includes two notable exceptions from the previous format.
First,
the syntax for bit-vectors sorts ${\tt (BitVec\ n)}$
is now written  ${\tt (\_\ BitVec\ n)}$.
Second,
all let-bindings do \emph{not} annotate the type of the variable being bound.
Previously, a let-term could be written ${\tt (let\ ((x\ t\ T)) ...)}$
where ${\tt T}$ indicates the type of ${\tt t}$.

%A let-binding
Furthermore, wherever applicable,
the syntax for sorts and terms
from other SMT theories assumes the syntax
prescribed in theory definitions from SMT LIB~\cite{}.

\item The command $\primedvardeclkwd$, which is syntax
sugar for two $\vardeclkwd$ commands, has been removed
for the sake of simplicity.

%\rem{Syntax for terms assumes smt2: especially BitVec and 3 argument let}

%\item Change (fail)?

\item Elaborations on the well-formedness of all commands.

\end{enumerate}

\section{Syntax}
\label{sec:syntax}

\ajr{General relation to smt2}

In this section, we describe the concrete syntax
of SyGuS version 2.0 inputs.
In the following description,
italicized text within angle-brackets represents EBNF non-terminals,
and text in typewriter font represents terminal symbols.

A SyGuS input $\sygus$ is thus a sequence of zero or more commands.
\[
\begin{array}{rcl}
\sygus & ::= & \kstar{\cmd}\\[2ex]
\end{array}
\]
The syntax for commands is given at the end of this section.
We first introduce the necessary preliminary definitions.

\subsection{Comments}

Comments in SyGuS specifications are indicated by a semicolon ${\tt ;}$.
After encountering a ${\tt ;}$, the rest of the line is ignored.

\subsection{Literals}
\label{ssec:literals}

A \emph{literal} $\literal$ is a special sequence of characters.
The SyGuS format includes syntax for several kinds of literals,
listed below.

\begin{alignat*}{1}
 & \begin{array}{rcl}
\literal & ::= & \begin{array}{ccccccccccc}
\intconst & | & \realconst & | & \boolconst & | \\
\hexconst & | & \binaryconst & | & \stringconst\end{array}\\
\intconst & ::= & \begin{array}{ccc}
\kplus{\left[{\tt 0}-{\tt 9}\right]} & | & {\tt -}\kplus{\left[{\tt 0}-{\tt 9}\right]}\end{array}\\
\realconst & ::= & \begin{array}{ccc}
\kplus{\left[{\tt 0}-{\tt 9}\right]}{\tt .}\kplus{\left[{\tt 0}-{\tt 9}\right]} & | & {\tt -}\kplus{\left[{\tt 0}-{\tt 9}\right]}{\tt .}\kplus{\left[{\tt 0}-{\tt 9}\right]}\end{array}\\
\boolconst & ::= & \begin{array}{ccc}
\truekwd & | & \falsekwd\end{array}\\
\hexconst & ::= & \begin{array}{c}
{\tt \#x}\kplus{\left(\begin{array}{ccccc}
\left[{\tt 0-9}\right] & | & \left[{\tt a}-{\tt f}\right] & | & \left[{\tt A}-{\tt F}\right]\end{array}\right)}\end{array}\\
\binaryconst & ::= & \begin{array}{c}
{\tt \#b}\kplus{\left[{\tt 0}-{\tt 1}\right]}\end{array}\\
\end{array}
\end{alignat*}

Integer constants are written as usual, in decimal, with an optional
minus at the beginning to denote a negative number. Real numbers are
written using their decimal expansion: at least one decimal digit
before and after a mandatory period, and an optional minus sign at
the beginning. $\truekwd$ and $\falsekwd$ are the predefined boolean
constants.
Hexidecimal and binary constants are written in their
traditional representations.

Additionally,
a string literal $\stringconst$
is any sequence of printable characters
delimited by the double quotes character ${\tt ``}$.
\rem{TODO: double quotes escape}
This definition coincides with
string literals in Section 3.1 of the SMT LIB version 2.6 format.

Literals are commonly
used for denoting 0-ary symbols of a theory.
For example, 
the theory of integer arithmetic 
uses integer constants to denote integer values.
The theory of bit-vectors uses both
hexidecimal and binary constants in the above syntax
to denote bit-vector vectors.
For more details on concrete theory definitions,
see Section~\ref{sec:smt-theories}.


\subsection{Symbols}

Symbols are denoted with the non-terminal $\symbol$. 
A symbol
is any non-empty sequence of upper- and lower-case alphabets, digits,
and certain special characters (listed below), with the restriction that it may not
begin with a digit and is not a reserved word (see Appendix~\ref{apx:reserved} 
for a full list of reserved words).
A special character is any of the following:
\[
{\tt \_}\mbox{ }{\tt +}\mbox{ }{\tt -}\mbox{ }{\tt *}\mbox{ }{\tt \&}\mbox{ }{\tt |}\mbox{ }{\tt !}\mbox{ }{\tt \sim}\mbox{ }{\tt <}\mbox{ }{\tt >}\mbox{ }{\tt =}\mbox{ }{\tt /}\mbox{ }{\tt \%}\mbox{ }{\tt ?}\mbox{ }{\tt .}\mbox{ }{\tt \$}\mbox{ }{\tt \mathcircumflex}
\]
Note this definition coincides with
symbols in Section 3.1 of the SMT LIB version 2.6 format,
apart from differences in their reserved words.

\subsection{Identifier}

An identifier $\identifier$
is a syntactic extension of symbols 
that includes indexed symbols.
\[
\begin{array}{rcl}
\identifier & ::= & \begin{array}{ccc}
\symbol & | & \paren{{\tt \_}\mbox{ }\symbol\mbox{ }\kplus{\identifierindex}}
\end{array}\\
\identifierindex & ::= & \begin{array}{ccc}
\intconst & | & \symbol
\end{array}\\
\end{array}
\]
Note this definition coincides with
identifiers in Section 3.1 of the SMT LIB version 2.6 format.

\subsection{Sorts}

A sort $\sortexpr$ denotes the

\begin{alignat*}{1}
 & \begin{array}{rcl}
\sortexpr & ::= & \identifier\mbox{ }|\mbox{ }\paren{\identifier\mbox{ }\kplus{\sortexpr}}\\
\end{array}
\end{alignat*}
The \emph{arity} of the sort is the number of (sort) arguments it takes.
Theories associate identifiers with sorts and sort constructors
that have an intended semantics.
Examples of such sorts that are defined by theories 
are given in Section~\ref{sec:smt-theories}.
Sorts may also be user-defined (see Section~\ref{ssec:defining-sorts}.

\subsection{Terms}

Terms $\term$ are used to specify grammars and constraints.
\begin{alignat*}{1}
 & \begin{array}{rcl}
\term & ::= & \qualidentifier\\
 & | & \literal\\
 & | & \paren{\qualidentifier\mbox{ }\kplus{\term}}\\
 & | & \paren{\existskwd\mbox{ }\paren{\kplus{\sortedvar}}\mbox{ }\term}\\
 & | & \paren{\forallkwd\mbox{ }\paren{\kplus{\sortedvar}}\mbox{ }\term}\\
 & | & \paren{\letkwd\mbox{ }\paren{\kplus{\varbinding}}\mbox{ }\term}\\[2ex]
 \bfterm & ::= & \qualidentifier\\
 & | & \literal\\
 & | & \paren{\qualidentifier\mbox{ }\kplus{\bfterm}}\\[2ex]
 \qualidentifier & ::= & \identifier\mbox{ }|\mbox{ }\paren{\askwd\mbox{ }\identifier\mbox{ }\sortexpr}\\
 \sortedvar & ::= & \paren{\symbol\mbox{ }\sortexpr}\\
 \varbinding & ::= & \paren{\symbol\mbox{ }\term}\\
\end{array}
\end{alignat*}
Like sorts, the identifiers that comprise terms
can either be defined by the user or by the theory.
Examples of the latter are given in Section~\ref{sec:smt-theories}.



We distinguish a subclass of \emph{binder-free} terms $\bfterm$ in the syntax above,
which do not contain variable bindings.

\subsection{Commands}

A command $\cmd$ is given by the following syntax.

\[
\begin{array}{rcl}
\cmd 
 & ::= & \paren{\constraintkwd\mbox{ }\term} \\
 & | & \paren{\checksynthkwd} \\
 & | & \paren{\vardeclkwd\mbox{ }\symbol\mbox{ }\sortexpr}\\ 
 & | & \paren{\constraintinvkwd\mbox{ }\symbol\mbox{ }\symbol\mbox{ }\symbol\mbox{ }\symbol} \\
 & | & \paren{\setextensionkwd\mbox{ }\symbol} \\
 & | & \paren{\synthfunkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\koption{\grammardef}}\\
 & | & \paren{\synthinvkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\koption{\grammardef}} \\
 & | & \smtcmd \\[2ex]
 %\paren{\constdeclkwd\mbox{ }\symbol\mbox{ }\sortexpr} \\
\smtcmd 
 & ::= & \paren{\fundeclkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortexpr}}\mbox{ }\sortexpr} \\
 & | & \paren{\dtdeclkwd\mbox{ }\symbol\mbox{ }\dtdec} \\
 & | & \paren{\dtsdeclkwd\mbox{ }\paren{\kstarn{\sortdecl}{n+1} }\mbox{ }\paren{\kstarn{\dtdec}{n+1}}} \\
 & | & \paren{\sortdeclkwd\mbox{ }\symbol\mbox{ }\intconst} \\
 & | & \paren{\fundefkwd\mbox{ }\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\term} \\  %\fundef
 %& | & \paren{\recfundefkwd\mbox{ }\fundef} \\
 %& | & \paren{\recfunsdefkwd\mbox{ }\paren{\kstarn{\fundec}{n+1}}\mbox{ }\paren{\kstarn{\term}{n+1}}} \\
 & | & \paren{\sortdefkwd\mbox{ }\symbol\mbox{ }\sortexpr} \\
 & | & \paren{\setlogickwd\mbox{ }\symbol} \\
 & | & \paren{\setoptkwd\mbox{ }\option} \\[2ex]
 \sortdecl & ::= & \paren{\symbol\mbox{ }\intconst}\\
 %\sortedvar & ::= & \paren{\symbol\mbox{ }\sortexpr}\\  %ajr: used above
 %\fundec & ::= & \paren{\symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr}\\
 %\fundef & ::= & \symbol\mbox{ }\paren{\kstar{\sortedvar}}\mbox{ }\sortexpr\mbox{ }\term\\
 \dtdec & ::= & \paren{\kplus{\dtconsdec}} \\
 \dtconsdec & ::= & \paren{\symbol\mbox{ }\kstar{\sortedvar}} \\
 \grammardef & ::= & \paren{\kstarn{\sortedvar}{n+1}}\mbox{ }\paren{\kstarn{\ntdef}{n+1}} \\
 \ntdef & ::= & \paren{\symbol\mbox{ }\paren{ \kplus{\gterm} } } \\[2ex]
 \gterm 
 & ::= &  \paren{\constantkwd\mbox{ }\sortexpr}\mbox{ }|\mbox{ }\paren{\varkwd\mbox{ }\sortexpr}\mbox{ }|\mbox{ }\bfterm\\
\end{array}
\]
For conveinence,
we distinguish two kinds of commands above.
The commands listed under $\cmd$ are specific to the SyGuS version 2.0 standard.
The remaining commands listed under $\smtcmd$
are borrowed from the SMT LIB version 2.6 standard.
Details on the semantics of these commands are given in Section~\ref{sec:semantics}.

%\paragraph{Reserved Words}
%All strings mentioned in Section~\ref{ssec:literals}


\section{Semantics of Commands}
\label{sec:semantics}

A SyGuS input file is a sequence of commands,
which at a high level
are used for defining a (single) synthesis conjecture
and invoking a solver for this conjecture.
This conjecture is of the form:
\begin{alignat*}{1}
 & \exists f_1,\ldots,f_n.\, \forall x_1,\ldots,x_m.\,(\varphi_1 \wedge \ldots \wedge \varphi_p )[f_1,\ldots,f_n,x_1,\ldots,x_m]
\end{alignat*}
In this section, we define how this conjecture is
is established via SyGuS commands.
%At a high level, 
%functions to synthesize $f_1, \ldots, f_n$ 
In the following,
we refer to
$f_1, \ldots, f_n$ as the current set of \emph{functions to synthesize},
$x_1, \ldots, x_m$ as the current set of \emph{universal variables}, and 
$\varphi_1, \ldots, \varphi_p$ as the current set of \emph{constraints}.

We refer to the current \emph{signature}
as the set of defined symbols in the current scope.
In this context, 
a signature is 
a mapping from symbols to expressions (either sorts or terms).
\rem{Details}

In the following section, we describe how each command updates
the state of the sets above and the current signature.

\subsection{Setting the Logic}

\begin{itemize}
\item $\paren{\setlogickwd\mbox{ }S}$

The logic $S$ can be one defined in SMT-LIB~\cite{},
but may be solver-specific.
For examples of common SMT logics, 
see Section~\ref{sec:smt-theories}.
If $S$ is an SMT-LIB standard logic,
then this command adds the set of sort and function symbols
from that logic to the current signature.
Additionally, in this case,
the logic must contain quantifiers,
that is, logics with the prefix ``${\tt QF\_}$'' are not allowed.

\item $\paren{\setextensionkwd\mbox{ }S}$

This enables the extension specified by $S$.
This may correspond enabling a feature of the language
or logic that is not supported by default.
\rem{Details, see}

\end{itemize}

\subsection{Declaring Universal Variables}

\begin{itemize}
\item $\paren{\vardeclkwd\mbox{ }S\mbox{ }\sigma}$

This command adds $S$ to the current set of universal variables
and adds the symbol $S$ of sort $\sigma$ to the current signature.

%\item $\paren{\constdeclkwd\mbox{ }\symbol\mbox{ }\sortexpr}$

\item $\paren{\fundeclkwd\mbox{ }S\mbox{ }\paren{\sigma_1 \ldots \sigma_n}\mbox{ }\sigma}$

This command adds $S$ to the current set of universal variables.
The sort of $S$ is $\sigma$ if $n=0$ or
$\sigma_1 \ldots \sigma_n \rightarrow \sigma$ if $n>0$.
\rem{Mention this is higher-order quantification}

\end{itemize}

\subsection{Declaring Functions-to-Synthesize}

\begin{itemize}
\item $\paren{\synthfunkwd\mbox{ }S\mbox{ }
\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\sigma\mbox{ }
\koption{G}}$

The syntax for the grammar $G$ (if provided)
consists of two parts: 
a \emph{predeclaration}
$\paren{\paren{y_1\mbox{ }\tau_1} \ldots \paren{y_n\mbox{ }\tau_n}}$,
followed by a \emph{rule list}
$\paren{\paren{y_1\mbox{ }\paren{g_{11} \ldots g_{1m_1} } } \ldots \paren{y_n\mbox{ }\paren{g_{n1} \ldots g_{1m_n} } }}$
where $y_1, \ldots, y_n$ are the \emph{non-terminal} symbols of the grammar.
For all $i,j$, recall that $g_{ij}$ is either a term, or a class of terms
denoted by $\paren{\constantkwd\mbox{ }\sigma_c}$ 
and $\paren{\varkwd\mbox{ }\sigma_v}$ denoting respectively
the (possibly infinte) set of constants whose sort is $\sigma_c$,
and the set of all variables from $x_1, \ldots, x_n$ whose sort is $\sigma_v$.
If $g_{ij}$ is an ordinary term, then its free variables may contain $y_1, \ldots, y_n$.
Note that the same variable symbols
$y_1, \ldots, y_n$ appear both in the predeclaration and as heads
of each of the rules.
If this is not the case, then this command is not well-formed.
Furthermore,
this command is not well-formed if
$\tau_1$ is not $\sigma$.\rem{First symbol of grammar instead of distinguished Start keyword?},
It is also not well-formed if
it is possible to generate a term $t$ with $G$ starting from $y_i$
that does not have type $\tau_i$ for some $i$.
Details on grammars and the terms
they generate is discussed in more detail in Section~\ref{ssec:sat-syntactic}.

If $G$ is not provided,
then this command is syntax
sugar for
$\paren{\synthfunkwd\mbox{ }S\mbox{ }
\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\sigma\mbox{ }
G_{\mathcal{L},\vec{x},\sigma}}$
where $G_{\mathcal{L},\vec{x},\sigma}$ is a grammar that
generates all well-sorted terms of sort $\sigma$ 
that belong the language of the current background logic $\mathcal{L}$,
and whose free variables are in $x_1, \ldots, x_n$.
%We call $G_{\mathcal{L},\sigma,\vec{x}}$ the \emph{default}
%grammar for $(T,\sigma,\vec{x})$.

This command adds $S$ to the current set of functions to synthesize,
and adds the symbol $S$ of 
sort $\sigma_1 \times \ldots \sigma_n \rightarrow \sigma$
to the current signature.


\item $\paren{\synthinvkwd\mbox{ }S\mbox{ }\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\koption{G}}$

This is syntax sugar for
$\paren{\synthfunkwd\mbox{ }S\mbox{ }\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n} }\mbox{ }\boolkwd\mbox{ }\koption{G}}$.
\end{itemize}

\subsection{Defining Sorts}
\label{ssec:defining-sorts}

\begin{itemize}
\item $\paren{\dtdeclkwd\mbox{ }S\mbox{ }D}$

This is syntax sugar for
$\paren{\dtsdeclkwd\mbox{ }\paren{\paren{S\mbox{ }0} }\mbox{ }\paren{D}}$.

\item $\paren{\dtsdeclkwd\mbox{ }\paren{\paren{S_1\mbox{ }m_1}\ldots\paren{S_n\mbox{ }m_n} }\mbox{ }\paren{D_1 \ldots D_n}}$

This command adds the symbols $S_1, \ldots, S_n$ to the current signature
and associates it with a datatype sorts
whose definitions are given by $D_1, \ldots, D_n$.
The integer constant $m_i$ denotes the arity of datatype $D_i$.
\rem{Details}

We provide examples of datatype definitions in Section~\ref{sec:examples}.
For full details on well-formed datatype declarations,
refer to Section 4.2.3 of the SMT LIB version 2.6~\cite{}.

\item $\paren{\sortdeclkwd\mbox{ }S\mbox{ }n}$

This command adds the symbol $S$ to the current signature
and associates it with an uninterpreted sort of arity $n$.

\end{itemize}

\subsection{Defining Macros}

\begin{itemize}
\item $\paren{\fundefkwd\mbox{ }S\mbox{ }\paren{\paren{x_1\mbox{ }\sigma_1} \ldots \paren{x_n\mbox{ }\sigma_n}}\mbox{ }\sigma\mbox{ }t}$

This adds to the current signature
the symbol $S$ of sort $\sigma$
if $n=0$ or $\sigma_1 \times \ldots \sigma_n \rightarrow \sigma$ if $n>0$.
The variables $x_1, \ldots, x_n$ may occur freely in $t$.
It defines $S$ as a term whose semantics
are $\lambda x_1, \ldots, x_n.\, t$.
Notice that $t$ may not contain any free occurrences of $S$,
that is, the definition above is not recursive.

\item $\paren{\sortdefkwd\mbox{ }S\mbox{ }\paren{u_1 \ldots u_n}\mbox{ }\sigma}$

This adds the symbol $S$ to the current signature.
It defines $S$ as the sort $\sigma$.
The sort variables $u_1, \ldots, u_n$
may occur free in $\sigma$.


\end{itemize}

\subsection{Asserting Synthesis Constraints}

\begin{itemize}
\item $\paren{\constraintkwd\mbox{ }t}$

This adds $t$ to the set of constraints.
This command is well formed if $t$ is a formula,
that is, a term of Boolean sort.

\item $\paren{\constraintinvkwd\mbox{ }S\mbox{ }S_{pre}\mbox{ }S_{trans}\mbox{ }S_{post}}$

%This command is syntax-sugar for
%declaring a set of variables 
%and asserting a constraint corresponding to the invariant synthesis problem.
A constraint of this form is well-formed if:
\begin{enumerate}
\item
$S$ is function-to-synthesize
of sort $\sigma_1 \times \ldots \sigma_n \rightarrow $,
\item
$S_{pre}$ is a defined symbol 
whose definition is of the form $\lambda x_1, \ldots, x_m.\, t_{pre}$,
\item
$S_{trans}$ is a defined symbol 
whose definition is of the form $\lambda x_1, \ldots, x_m, y_1, \ldots, y_n.\, t_{trans}$, and
\item
$S_{post}$ is a defined symbol 
whose definition is of the form $\lambda x_1, \ldots, x_m.\, t_{post}$.
\end{enumerate}

\rem{TODO}


\end{itemize}

\subsection{Initiating Synthesis Solver}

\begin{itemize}
\item $\paren{\checksynthkwd}$

This asks the synthesis solver to find a solution for the synthesis conjecture
corresponding to the current set of functions-to-synthesize,
universal variables and constraints.
The expected output from the synthesis solver is covered in Section~\ref{sec:output}.
\end{itemize}

\subsection{Setting Solver Options}

\begin{itemize}
\item $\paren{\setoptkwd\mbox{ }O}$

This sets 
It is recommended that synthesis solvers
ignore unrecognized options, 
and choose reasonable defaults when the
options are left unspecified.
\end{itemize}

\section{Synthesis Solver Output}
\label{sec:output}

This section covers the expected output from a synthesis solver,
which currently is limited to responses to $\checksynthkwd$ 
only.

\begin{itemize}
\item
A well-formed response to $\checksynthkwd$ is one of the following:

\begin{enumerate}
\item
A list of $\fundefkwd$ commands of the form:
\[
\begin{array}{l}
{\tt (}\fundefkwd\mbox{ }f_{o1}\mbox{ }X_{o1}\mbox{ }\sigma_{o1}\mbox{ }t_{o1}{\tt )}\\
\ldots\\
{\tt (}\fundefkwd\mbox{ }f_{on}\mbox{ }X_{on}\mbox{ }\sigma_{on}\mbox{ }t_{on}{\tt )}
\end{array}
\]
where functions $\{ f_{o1}, \ldots, f_{on} \}$
are the functions-to-synthesize $\{ f_1,\ldots,f_n \}$ (in any order), 
$X_{o1}, \ldots, X_{on}$ are sorted variable lists,
$\sigma_{o1}, \ldots, \sigma_{on}$ are types,
and $t_{o1}, \ldots, t_{on}$ are terms.
To be a well-formed output, 
for each $j=1, \ldots, n$, it must be the case that
$t_{oj}$ is a term of $\sigma_{oj}$,
and $X_{oj}$ is identical to the sorted variable list
used when introducing the function-to-synthesize $f_{oj}$.

\item
The output ${\tt (fail)}$.

\end{enumerate}
\end{itemize}

%\section{

\section{Logical Semantics and Restrictions}
\label{sec:logical-semantics}

\subsection{Logic}

\rem{Logic e.g. Non-linear vs linear: generated terms}

\rem{Quantifiers implicit, but disallowed in contraints}

\rem{Summarize logic restrictions regarding what symbols appear where}

\rem{Special logics: single invariant synthesis}

\subsection{Satisfying Syntactic Specifications}
\label{ssec:sat-syntactic}
\rem{Formalize fits grammar}

Given a grammar


\subsection{Satisfying Semantic Specifications}
\label{ssec:sat-semantic}
\rem{Reference smt semantics}


\section{SMT LIB Version 2.6 Theory References}
\label{sec:smt-theories}

In this section, for conveinence, we provide the concrete
grammar corresponding to the (full) signature
of a number of theories of interest.
Note this is not intended to be a complete list of all theories.

\subsection{Integer Arithmetic}



\subsection{Real Arithmetic}



\subsection{Fixed-Width Bit-Vectors}



\subsection{Strings}


\section{Examples}
\label{sec:examples}

\rem{Simple LIA example}

\rem{Datatypes}


\begin{appendix}

\section{Reserved Words}
\label{apx:reserved}

A \emph{reserved word} is any of the 
literals from Section~\ref{ssec:literals},
or any of the following keywords:

\section{Language Features of SMT LIB not Covered}

For the purpose of self-containment,
many of the essential language features of SMT LIB version 2.6
are redefined in this document.
However, others are omitted.
%We do not explicitly forbid the language features of SMT LIB .
We briefly mention other pertinent language features not mentioned in
this document.

Parametric datatypes

Recursive functions 

Match terms

Attribute annotations

\end{appendix}

\bibliographystyle{plain}
\bibliography{references}

\end{document}
